INCLUDERC="/secure/email/nixspam.global.procmailrc"

# [JM]
# heavily modified version of NixSpam, used primarily by
# /usr/bin/local/createmailaccount.sh
# [/JM]

# if we haven't hit a delivery recipe yet, we check the email
# for spaminess

# Ausgabe 2004-08-04 (ersetzt 2004-02-05)

# # # Anfang des Deklarationsteils 

# Envelope-To explizit vorhanden?
:0
* ^Envelope-to: \/.+@.+
{ ENVELOPE_TO=$MATCH }
# sonst Envelope-To aus Received-Zeilen ermitteln:
:0E
* $ 1^1 Received:.*for [<]?\/[^<]+$MY_DOMAIN
{ ENVELOPE_TO=$MATCH }
:0E
{ CHECK="WARNING: Envelope-To not found!
$CHECK" }

# Local Part (nicht immer = $LOGNAME) aus Envelope-To:
:0
* ENVELOPE_TO ?? .*\/[^@]+
  { ENV_TO=$MATCH
  :0
  { CHECK="Envelope-To: $ENVELOPE_TO
$CHECK" }
}

# Intranet-Mails nicht filtern:
:0
# Erste Zeile mit dem eigenen MX extrahieren:
* $ ^Received:.from.\/.*by.$MY_MX
# Adresse nach RFC 1918?
* MATCH ?? [([](10|172\.(1[6-9]|2[0-9]|3[01])|192\.168)\.
{ CHECK="HEADER_TESTS_SKIPPED
-OK-
-OK-HOST (interne E-Mail)
$CHECK" }
# Auch nicht filtern, wenn eigener MX gar nicht vorkommt:
:0E
* $ ! MATCH ?? $MY_MX
{ CHECK="HEADER_TESTS_SKIPPED
-OK-
-OK-HOST (interne E-Mail)
$CHECK" }

# Mail intern neu gesendet. Geht davon aus, dass der
# Header mit einer "Resent"-Zeile aufhoert und dass
# MY_MX bei externen Mails die letzte Header-Zeile
# anfuegt (sonst sehr leicht faelschbar).
:0E
* ^Resent-.*$$^^
{ CHECK="HEADER_TESTS_SKIPPED
-OK-
-OK-HOST (neu gesendet, intern)
$CHECK" }

# Auch inoffizielle Verteileradresse durchlassen:
:0E
* $ ^((Envelope-)?To|CC):.*\/$LIST_ALIASES
{ CHECK="HEADER_TESTS_SKIPPED
-OK-
-OK-VERTEILER: $MATCH
$CHECK" } 

# Whitelist-/Blacklist-Check:
:0E
# Nicht bei Fehlermeldungen:
* 2^0
* -1^0 ^(From |Return-path).*(admin|root|Mailer-Daemon|Postmaster|virus)
* -1^0 ^Subject.*(deliver|fail|return|mail|virus|message)
{
  # Received-Zeile mit dem Absender-Gateway extrahieren:
  :0
  # letzten Treffer suchen, der ein eigenes Gateway enthaelt ...
  * $ 1^1 ^Received:.from.*(\[|\()[.0-9]+(\]|\)).*by.\/$MY_MX_NAME
  # ... und davon den ersten, da alle weiteren gefaelscht sein koennen:
  * $ ^Received:.from.\/.*(\[|\()[.0-9]+(\]|\)).*by.$MATCH
  { RECEIVED=$MATCH }

  # Reverse Lookup extrahieren, falls vorhanden (setzt
  # die Form "Received: from rdns.look.up ..." voraus),
  # andere MTAs tragen vor der Klammer die HELO-
  # Angabe oder gar nichts ein:
  :0
  * RECEIVED ?? ^^\/[^[(]+
  { REVERSELOOKUP=$MATCH }

  # IP-Nummer in Black- oder Whitelist?
  :0
  * RECEIVED ?? .*[[(]\/[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+
  # Sicher ist sicher: keine internen Adressen ...
  * ! MATCH ?? ^^(10|172\.(1[6-9]|2[0-9]|3[01])|192\.168)\.
  { GATEWAY_IP="$MATCH"
    :0 w
    # nur die ersten drei Adress-Bytes checken:
    * MATCH ?? ()\/.+\.
    * ? fgrep -s -- " $MATCH" $WHITELIST
    { CHECK="HEADER_TESTS_SKIPPED
-OK-WHITELIST_MATCH: $MATCH
$CHECK" }
    :0 Ew
    * ? fgrep -s -- " $MATCH" $BLACKLIST
    { CHECK="NiX-
NiX-
NiX-BLACKLIST_MATCH: $MATCH
$CHECK" }
  }
  :0E
  { CHECK="NO BL/WL CHECK ON $MATCH
$CHECK" }
} # Ende Black-/Whitelist-Check
:0E
{ CHECK="BLACK-/WHITELIST CHECK SKIPPED
$CHECK" }

# Pruefsummen bilden:
:0 D
* ! CHECK ?? ^-OK-(HOST|VERTEILER)
{
  # Voraussetzung fuer die erste Fuzzy Checksum (etwas Leerraum):
  :0B
  * [ 	].+[ 	].*$?.*$?.*[ 	]
  {
    # Erste Checksum: Nur Returns und Leerraum belassen:
    :0 bw
    md5hash=|tr -s '[:space:]' \
            |tr -d '[:graph:]‰ˆ¸Èƒ÷‹…ﬂ' \
            |md5sum
    # Hashsumme bereits in der Datei?
    :0 ADw
    * ? fgrep -s $md5hash $SPAMCACHE
    { CHECK="NiX-
NiX-
NiX-
NiX-
NiX-
NiX-
NiX-
NiX-CHECKSUM1_SPAM: $md5hash
HEADER_TESTS_SKIPPED
$CHECK" }
    :0 Ew
    * ? fgrep -s $md5hash $MD5CACHE
    { CHECK="NiX-
NiX-CHECKSUM1: $md5hash
$CHECK" }
  }
  :0B
  # zweite Checksum nur bilden, wenns nicht schon einen Treffer gab:
  * ! CHECK ?? ^NiX-CHECKSUM
  # Mindestanforderungen fuer die zweite Fuzzy Checksum
  # (Satzzeichen, URL o. ae. im Body):
  * ([<>()|@*'!?,]|//)
  { :0 bw
    # Zweite Checksum: Ziffern, Buchstaben, '=' und Returns entfernen
    # NEU: %&#; entfernen (oft in HTML-Schweinereien)
    # NEU: sowie Unterstriche in Punkte umwandeln:
    md5hash2=|tr -d '[:cntrl:][:alnum:]%&#;‰ˆ¸Èƒ÷‹…ﬂ=' \
             |tr '_' '.' \
             |tr -s '[:print:]' \
             |md5sum
    # Hashsumme bereits in der Datei?
    :0 ADw
    * ? fgrep -s $md5hash2 $SPAMCACHE
    { CHECK="NiX-
NiX-
NiX-
NiX-
NiX-
NiX-
NiX-
NiX-CHECKSUM2_SPAM: $md5hash2
HEADER_TESTS_SKIPPED
$CHECK" }
    :0 EDw
    * ? fgrep -s $md5hash2 $MD5CACHE
    { CHECK="NiX-
NiX-CHECKSUM2: $md5hash2
$CHECK" }
    # Hashes zusammenfassen:
    :0
    * md5hash2 ?? .
    { md5hash="$md5hash	$md5hash2" }
  }
  :0DB
  # Weniger unscharf bei Base64- oder anderen strukturlosen Mails:
  * ! md5hash ?? .
  # Voraussetzung hier: ein paar nicht-leere Zeichen im Body.
  * [^	 ][^	 ][^	 ][^	 ]
  {
    :0 bw
    md5hash=|tr -d '[:cntrl:][:space:]=' \
            |tr -s '[:graph:]' \
            |md5sum
    :0 ADw
    * ? fgrep -s $md5hash $SPAMCACHE
    { CHECK="NiX-
NiX-
NiX-
NiX-
NiX-
NiX-
NiX-
NiX-CHECKSUM_SPAM: $md5hash
HEADER_TESTS_SKIPPED
$CHECK" }
    :0 Ew
    * ? fgrep -s $md5hash $MD5CACHE
    { CHECK="NiX-
NiX-CHECKSUM: $md5hash
$CHECK" }
  }
} # (Ende des Pruefsummen-Teils)

# Immer Ham - eigener Vor- und Nachname in Adresszeile:
:0
* ! CHECK ?? ^-OK-WHITELIST_MATCH
* MY_FIRSTNAME ?? ..
* MY_LASTNAME ?? ..
# Option fuer Paranoide: nicht, wenn Name aus Account generierbar:
# * $ ! ENV_TO ?? [^a-z]($MY_FIRSTNAME[^a-z]+$MY_LASTNAME|\
#                        $MY_LASTNAME[^a-z]+$MY_FIRSTNAME)[^a-z]
# zwei Tests, da Reihenfolge der Namen egal:
* $ ^(CC|(Resent-)?To):.*([^-+a-z0-9.@_]$MY_FIRSTNAME\
    [^+-a-z0-9.@_]|=\?.*$MY_FIRSTNAME.*\?=)
* $ ^\/(CC|(Resent-)?To):.*([^-+a-z0-9.@_]$MY_LASTNAME\
    [^+-a-z0-9.@_]|=\?.*$MY_LASTNAME.*\?=)
{ CHECK="HEADER_TESTS_SKIPPED
-OK-
-OK-
-OK-TO_WITH_NAME: $MATCH
$CHECK" }

# alle anderen Mails genauer unter die Lupe nehmen:
:0 D
* ! CHECK ?? ^HEADER_TESTS_SKIPPED$
{
# Verdaechtig: E-Mail ohne jeden Klartext,
# entsprechender Hinweis schon im Header:
:0
* ^Content-.*base64
{ CHECK="NiX-
NiX-BASE64ONLY
$CHECK" }

# BCC: ist schonmal ziemlich spammig:
:0
* MY_ALIASES ?? ..
* $ ! ^((Resent-)?To|CC):.*(\<$LOGNAME\>|$MY_ALIASES|$LIST_ALIASES)
{ CHECK="NiX-BCC
$CHECK" }

# Abfrage der individuell deklarierten "guten"
# Gateways, beispielhaft ergaenzt um eine fest kodierte
# "Start-Whitelist" (u. a. Amazon (207...), Paypal
# (64...), Heise (193.99.144...), Yahoo und
# eBay). Filterung auf DNS-Namen setzt voraus, dass der
# MTA ein Reverse DNS Lookup in den Header schreibt,
# erst danach (hinter [,=]) darf die (beliebige)
# HELO-Angabe folgen. Unter Umstaenden muss man sich
# sonst auf IP-Nummern beschraenken.
:0
* RECEIVED ?? .
* -1^0 ! HOST_OK ?? .
* $ 1^0 RECEIVED ?? ^^[^,=]*\/$HOST_OK
* $ 1^0 RECEIVED ?? ^^[^,=]*\/([([](207\.171\.|64\.4\.2|193\.99\.144\.)|\
  sjc\.ebay|\.cal\.yahoo|siaa.*compuserve|\.scd\.yahoo\.|\
  \.t-mobile\.|rwth-aachen|uni-stuttgart|\
  uni-duisburg)
* ! MATCH ?? ([he]+lo )
{ CHECK="-OK-
-OK-
-OK-GATEWAY: $MATCH
$CHECK" } 

# stark verdaechtige Bestandteile von Absender-Adressen:
:0 E
* ^\/(From|Received|Reply|Return).*(deal[sz]|jackpot|mortgage|penis|netscap[^e]|saving[sz]|\
  auction|price|offer[sz]|sale[sz]|promo|bargain|porn|casino|vendi|altavista|\
  j-connect|usedviper|@name-|affil|remov|everyone|outblaze|consumer|\
  (pre|sub)scri|girl[sz]|cheap|free[^nm]|(per|sub)mis|special.?offer|[0-9][0-9][0-9]\.co[m.])
{ CHECK="NiX-
NiX-
NiX-SPAM_ADDRESS: $MATCH
$CHECK" } 

# diese Headerzeilen kommen nur in Spam vor:
:0
* ^\/(X-)?(RBL|XRef|(anti)?abuse).*
{ CHECK="NiX-
NiX-
NiX-
NiX-SPAM_HEADER: $MATCH
$CHECK" } 

# zu phantasievolle Zeitzone:
:0
* ^\/Date:.*[+-]([2-9][0-9][0-9][0-9]|1[3-9])
{ CHECK="NiX-
NiX-
NiX-
NiX-TIMEZONE_FAKE: $MATCH
$CHECK" } 

# Keine externen Received-Zeilen (Direktspam, gerne
# auch Viren- und Wurm-Output):
:0
* 1^0
* -1^1 ^Received:
* $ 1^1 ^Received:.*by.[.-a-z0-9]*($MY_DOMAIN|$MY_MX)
{ CHECK="NiX-
NiX-DIRECT_DELIVERY
$CHECK" }

# Verwurmte und trojanisierte PCs mit dynamischen
# Adressen sowie ein paar notorische Muell-Gateways:
:0
* $ ^Received:.from.\/(.+[he]+lo[ =])?[^[(]*([0-9][^[(]*[0-9][^[(]*[0-9][^[(]*[0-9]|\
    [^a-z](.?dsl|dial(in|up)?|pool|dhcp|dyn|client|user|ppp?o?e?|\
    wll|ipt\.aol|seed|charter|cust|bluerocketonline|tekmailer)[^a-z])\
    .*by.$MY_MX_NAME
* MATCH ?? ^^\/.+(\)|\])+
# dedizierte Mail-Gateways sind an dieser Stelle unverdaechtig:
* ! MATCH ?? (pureserver|mout|mta|smtp|relay)
{ CHECK="NiX-
NiX-
NiX-SUSPECT_GATEWAY: $MATCH
$CHECK" }

:0 B
* ^^($| |	|=20)*.*[0-9a-z].*($| |	|=20)*^^
{ CHECK="NiX-
NiX-ONE_LINE_BODY
$CHECK" }
:0 EB
* ^^($| |	|=20)*^^
{ CHECK="NiX-
NiX-EMPTY_BODY
$CHECK" }
# Grosse Mails sind selten Spam:
:0 EB
* XXL_SIZE ?? ......
* $ > $XXL_SIZE
{ CHECK="-OK-XXL
$CHECK" }

# Gateway-Namen ohne Punkt oder mit vielen Ziffern sind suspekt und sollten noch 
# anderswo im Header auftauchen (z.B. Firmen-/Anwendername):
:0
* $ ^Received:.*(claiming to be \"|[he]+lo(=| ))\/([^.]+|[0-9].*[0-9].*[0-9].*[0-9].*)[")].*by.$MY_MX_NAME
* MATCH ?? .*\/[^")]+
* $ ! ^[^R].*$MATCH
{ CHECK="NiX-
NiX-SUSPECT_HELO: $MATCH
$CHECK" } 
# Noch schlimmer - MXe, die es nicht gibt:
:0 E
* ^Received:.*(claiming to be \"|[he]+lo(=| ))\/(aol|gmx)\.[^")]+
{ CHECK="NiX-
NiX-
NiX-SUSPECT_HELO: $MATCH
$CHECK" } 

# Absender hat angeblich unsere eigene Gateway-Adresse:
:0
* $ ^Received:.*\/(claiming to be ["]|[he]+lo(=| ))$MY_MX_IP
{ CHECK="NiX-
NiX-
NiX-
NiX-
NiX-
NiX-
NiX-GATEWAY_FAKE: $MATCH
$CHECK"
}

# Spamtrap-Adresse im Header:
:0
* $  [	 <,]\/$SPAMTRAPS
{ CHECK="NiX-
NiX-
NiX-
NiX-
NiX-
NiX-
NiX-SPAMTRAP_MATCH: $MATCH
$CHECK"
}

# Fake-Adresse aus Massen-Domain:
:0
* REVERSELOOKUP ?? .
* ^((X-)?Sender|Reply|From|Return).*@\/(angelfire|aol|excite|earthlink|\
  lycos|tripod|msn|yahoo|netscape|uni|juno|usa|(s|ch)ina|iname|\
  bluewin|chat.*|libero|gmx|indiatimes|terra|\
  [.-_a-z0-9]*(mail[-_a-z0-9]*|63))(\.com?)?\.[a-z]+[^-._a-z0-9]
* MATCH ?? ^^\/[^.]+
* $ ! REVERSELOOKUP ?? $MATCH
{ CHECK="NiX-
NiX-
NiX-
NiX-SPAM_DOMAIN: $MATCH
$CHECK" }

# Adresse mit Ziffern und Buchstaben: 
:0
* ^\/(Reply|From|Return).*([a-z][0-9]|[0-9][a-z])[^ =<>(]*@
{ CHECK="NiX-
NiX-NUMER1C_ACCOUNT: $MATCH
$CHECK" } 

# Adresse mit superlangem Account ohne Punkt:
:0
* ^((X-)?Sender|Reply|From|Return).*\/<..................[^. "]+@
* ! MATCH ?? [.]
{ CHECK="NiX-
NiX-
NiX-LONG_ACCOUNT: $MATCH
$CHECK" }

# Adresse mit ZeiChEnsalAt: 
:0 D
* ^\/((X-)?Sender|Reply|From|Return).*[a-z][A-Z][^ =<>(]*[a-z][A-Z][^ =<>(]*@
{ CHECK="NiX-
NiX-sPaM_ACCOUNT: $MATCH
$CHECK" } 

# Bounce-Adresse:
:0
* ^\/((X-)?Sender|Reply|From|Return).*(delete|owner|bounce|\
  no(reply|list)|error|return|\<list)[^ =<>(]*@
{ CHECK="NiX-SPAM_ACCOUNT: $MATCH
$CHECK" }

# Pseudo-Antwort: 
:0
* ^\/Subject: *(re|aw)\>
* ! ^(Reference|In-Reply)
# Der kann das nicht:
* ! ^X-Mailer.*Internet Mail Service
{ CHECK="NiX-REPLY_WITHOUT_REFERENCE: $MATCH
$CHECK" }
# ... und das Gegenteil davon:
:0 E
* ^\/(Reference|In-Reply).*
* ! ^\/Subject:.*\<(warn.ng|autoreply|re|aw):
{ CHECK="NiX-REFERENCE_WITHOUT_REPLY: $MATCH
$CHECK" }

# Pseudo-Referenz mit Zeichensalat:
:0
* ^\/(References|In-Reply-To): <[^>]+@.*([a-z][0-9]|[0-9][a-z])[^.>]*>
{ CHECK="NiX-BAD_REFERENCE: $MATCH
$CHECK" }
# Ordentliche Rueckbezuege dagegen sind Spam-untypisch:
:0 E
* ! CHECK ?? ^NiX-REFERENCE_WITHOUT_REPLY
* ^\/(References|In-Reply-To): <[^>]+@[^>]+>
* B ?? ^>
{ CHECK="-OK-REFERENCE: $MATCH
$CHECK" }

# Message-ID nicht vom Absender:
:0
# vom MTA generierte (Fehler-)Mails nicht testen:
* ^Return-path: <.+@.+>
* $ ^Message-ID:.*($MY_MX|@caipirinha\.heise\.de)
{ CHECK="NiX-
NiX-
NiX-MSG_ID_NOT_FROM_SENDER
$CHECK" }
# externe Message-IDs untersuchen und sichern:
:0 E
* ^Message-ID:\/.+
{ MSGID=$MATCH
  # kommt das Ende der ID sonst im Header vor?
  :0
  * MSGID ?? ()@\/[^>]+
  # Beliebte Fehlkonfigurationen ausnehmen:
  * ! MATCH ?? ^^[^0-9]*(192\.168|10)\.
  * MATCH ?? ()\/\.?[^.]+^^
  # Beliebte Fehlkonfigurationen ausnehmen:
  * ! MATCH ?? (local|\])
  * $ ! ^[^M].*$MATCH\>
  { CHECK="NiX-MSG_ID_SUSPECT: $MSGID
$CHECK"
    :0
    # Test auf besonders krasse Fakes mit Punkt, wenigstens
    # die "TLD" sollte irgendwo anders im Header auftauchen:
    * MATCH ?? ()\.
    * ! MATCH ?? ()\]
    { CHECK="NiX-
NiX-MSG_ID_DOMAIN_FAKE: $MATCH
$CHECK" }
  }
  :0 E
  * ! MSGID ?? [^<]+@[^>]+
  { CHECK="NiX-
NiX-MSG_ID_INVALID: $MSGID
$CHECK" }

  # allgemeine Suche nach nachtraeglich eingefuegten IDs:
  :0
  * ^Message-ID:(.|$)+^Received:
  { CHECK="NiX-MSG_ID_NOT_FROM_SENDER
$CHECK" }

}

# Spam-typische Mailer-Eintraege:
:0
* ^X-Mailer: \/(.*(bulk|egroup).*| *[^/-. ]*)$
{ CHECK="NiX-X_MAILER_SUSPECT: $MATCH$CHECK" }

# MIME-Attachment(s) vorhanden:
:0
* ^Content.*multipart
{
  # PDF- und .doc-Anhaenge sind meist vertrauenswuerdig:
  :0 B
  * ^--.*$.*Content.*$?.*name=\/".*(\.|=2E)(doc|pdf)([?]=)?"
  { CHECK="-OK-ATTACHMENT: $MATCH
$CHECK" }

  # Angehaengte E-Mails auch:
  :0 B
  * ^\/Content-Type:.message.*
  { CHECK="-OK-ATTACHMENT: $MATCH
$CHECK" }

  # Multipart-Mails mit nur einem MIME-Attachment,
  # ausschliesslich Base64-kodierten oder gar einem leeren:
  :0
  * ! CHECK ?? ^-OK-XXL
  # verschachtelte Anhaenge nicht untersuchen:
  * ! B ?? boundary="
  {
    # Gibts ein nicht-leeres, nicht base64-kodiertes Attachment?
    # Sonst Spam-Verdacht:
    :0 B
    * ^Content-Transfer-Encoding: base64
    * 1^0
    * -1^1 ^Content-type:
    * 1^1 ^Content-Transfer-Encoding: ([^b]|bi).*$$+--
    * 1^1 ^Content-Transfer-Encoding: base64
    { 
      CHECK="NiX-
NiX-BASE64ONLY
$CHECK"
      :0 B
      * ^Content-Type: text/html
      { CHECK="NiX-
NiX-
NiX-HTML_IN_BASE64ONLY
$CHECK" }
    }
    :0 B
    # Leere Attachments kommen normalerweise nur bei 
    # Weiterleitungen vor:
    * ^Content-.*$$([a-z ]*$)+--.*$+(Content-|^^)
    * ! ^Content-Type: message
    { CHECK="NiX-EMPTY_MIME_ATTACHMENT
$CHECK" }
    :0 B
    # Test, ob wirklich mehrere nicht-leere Parts vorhanden sind,
    # leeres Attachment daher auf Score draufschlagen:
    * 1^0 CHECK ?? ^NiX-EMPTY_MIME_ATTACHMENT
    * 2^0
    * -1^1 ^--.*$Content-
    { 
      CHECK="NiX-MULTIPART_FAKE
$CHECK" 
      :0 B
      * ^Content-Type: text/html
      { CHECK="NiX-
NiX-
NiX-HTML_ONLY_IN_MULTIPART_FAKE
$CHECK" }
    }
  }
}

# Verdaechtig: reines HTML,
# entsprechender Hinweis schon im Header:
:0
* ^Content-.*html
{ 
  CHECK="NiX-BODY_HTML_ONLY
$CHECK" 
  :0
  * CHECK ?? ^NiX-BASE64ONLY
  { CHECK="NiX-
NiX-
NiX-HTML_IN_BASE64ONLY
$CHECK" }
  :0 E
  * ^Content-Transfer-Encoding: quoted-printable
  { CHECK="NiX-HTML_IN_QUOTED_PRINTABLE
$CHECK" }
}

# Unwillkommene Zeichensaetze:
:0
* CHARSET ?? ...
* $ .*\/$CHARSET
 { CHECK="NiX-
NiX-
NiX-
NiX-CHARSET_IN_HEADER: $MATCH
$CHECK" }
# oder doch ein willkommener?
:0 E
* =\?\/iso-8859-1\?Q.*=(C4|E4|D6|F6|DC|FC|DF)
{ CHECK="-OK-UMLAUT_IN_HEADER: $MATCH
$CHECK" }
:0 EB
* CHARSET ?? ...
* ! CHECK ?? ^(-OK-XXL|NiX-BASE64ONLY)
* $ .*\/$CHARSET
 { CHECK="NiX-
NiX-
NiX-CHARSET_IN_BODY: $MATCH
$CHECK" }

# Base64-Kodierung im Header:
:0
* ^Subject: \/=\?.*\?B\?.*\?=$
{ CHECK="NiX-BASE64_SUBJECT: $MATCH$CHECK" }

# kein einziger Kleinbuchstabe im bzw. kein Betreff:
:0 D
* ! ^[Ss][Uu][Bb][Jj][Ee][Cc][Tt]:.*[a-z]
{ CHECK="NiX-SUBJECT_CAPSLOCK_OR_EMPTY
$CHECK" }

# Einige wenige, aber deutliche Einzelstichworte:
:0
* $ ^Subject:\/.*(y(o|0)u|(\<|_)adv(\>|_)|urgent)
{ CHECK="NiX-
NiX-SPAM_SUBJECT:$MATCH
$CHECK" }

# Betreff mit Zeichensalat, Massen an Leerzeichen etc.:
:0
* ^Subject: .*\/(\<\<\<\<\<\<\<\<\<\<|[a-z][01][a-z]).*
# Nicht bei Zeichensatz-Umkodierungen:
* ! MATCH ?? .\?=
{ CHECK="NiX-
NiX-SUBJECT_GARBAGE: $MATCH
$CHECK" }

# Spam mit persoenlicher Note (eigene Adresse im Subject):
:0
* ENV_TO ?? ..
* $ ^Subject.*\/\<$ENV_TO\>
{ CHECK="NiX-
NiX-SUBJECT_WITH_MY_ACCOUNT: $MATCH
$CHECK" }
# Spam mit persoenlicher Note (eigene Adresse im Subject):
:0E
* MY_ALIASES ?? ..
* $ ^Subject.*\/$MY_ALIASES
{ CHECK="NiX-
NiX-SUBJECT_WITH_MY_ACCOUNT: $MATCH
$CHECK" }

# So sehen manche "Nicht-Spam-Mails" aus,
# die sonst sehr verdaechtig sind:
:0
* ^X-MS-Has-Attach:
* ^X-MS-TNEF-Correlator:
{ CHECK="-OK-MS_MAILER
$CHECK" }

# Weiteres Zugestaendnis an manche PR-Aussender:
:0
* ^\/Received:.*(antivir|avmailgate|sweep|scan|viru).*
* $ ! MATCH ?? $MY_DOMAIN
{ CHECK="-OK-ANTIVIRUS: $MATCH
$CHECK" }

# Diese Headerzeilen gibts selten in Spam:
:0
* ^\/(Resent-|X-Mms|X-eBay-Mail)
{ CHECK="-OK-HAM_HEADER: $MATCH
$CHECK" }

# mehrere einzelne Buchstaben:
:0
* ^Subject:.*\/[^0-9a-z][a-z][^0-9a-z]+[a-z][^0-9a-z]+[a-z][^0-9a-z]
{ CHECK="NiX-SUBJECT_SPACED: $MATCH
$CHECK" } 

# Betreff-Whitelist auswerten:
:0
* SUBJECT_OK ?? ..
* $ ^Subject.*\/$SUBJECT_OK
* $ ! MATCH ?? $MY_ALIASES
{ CHECK="-OK-SUBJECT: $MATCH
$CHECK" }

# Absender-Whitelist auswerten:
:0
* DOMAIN_OK ?? ...
* $ ^From.*\/(@|\.)$DOMAIN_OK\.
{ CHECK="-OK-
-OK-SENDER: $MATCH
$CHECK" }

# Fehlender Realname:
:0
* ! ^From:.*((.+ )+(.+ )+.+|=\?.*_.*\?=)
{ CHECK="NiX-FROM_NOREALNAME
$CHECK" }

}

# Erster Versuch einer eindeutigen Einordnung:
:0 D
* CHECKSUM_PRIORITY ?? ^^Y
* CHECK ?? CHECKSUM.?_SPAM
{ RESULT="SPAM" }
:0 ED
* 1^0 ! CHECK ?? ^NiX-
* 1^0 CHECK ?? ^-OK-(WHITELIST_MATCH|TO_WITH_NAME|PASSWORD)
{ RESULT="HAM" }
:0 ED
* 10^0 CHECK ?? CHECKSUM.?_SPAM
* -6^0
* -2^3 CHECK ?? ^-OK-
* 1^1 CHECK ?? ^NiX-
{ RESULT="SPAM" }
:0 ED
* -4^0
* 2^3 CHECK ?? ^-OK-
* -1^1 CHECK ?? ^NiX-
{ RESULT="HAM" }
:0 ED
* CHECK ?? ^(-OK-XXL|NiX-(BASE64ONLY|EMPTY_BODY))
* -3^0
* -2^3 CHECK ?? ^-OK-
* 1^1 CHECK ?? ^NiX-
{ RESULT="MAYBESPAM" }

# Weitere Body-Untersuchung nur bei kleinen Klartext-Mails,
# die noch keinen deutlichen Ham- oder Spam-Status haben:
:0 D
* ! RESULT ?? .
* ! CHECK ?? ^(-OK-(HOST|XXL)|NiX-(BASE64ONLY|EMPTY_BODY))
{
  # Persoenliche Anrede, nur nicht mit Punkt im Namen:
  :0 B
  * MY_FIRSTNAME ?? ..
  * MY_LASTNAME ?? ..
  * $ .*\/\<(moin|dear|h[aeiu]|(ver|ge)ehrt|liebe|g(ood|ute))\
      .*(\<$MY_FIRSTNAME[^.a-z0-9]|[ _]$MY_LASTNAME)
  # Nicht, wenn Name aus Account generierbar:
  * ! ENV_TO ?? ($MY_FIRSTNAME|$MY_LASTNAME)
  { CHECK="-OK-
-OK-ANREDE: $MATCH
$CHECK" }

  # Sehr lange Zeile (mehr als 150 Zeichen):
  :0 B
  * ^\/..........................................................................\
     .............................................................................
  { CHECK="NiX-
NiX-LONG_LINE: $MATCH
$CHECK" }

  # "Click here" etc.:
  :0 B
  * .*\/\<(go|clic?k?|press|touch|push|check)[^.?!a-z]+(http|www|<a |now|here|(on.)?th)
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # "Click here" auf Deutsch:
  :0 B
  * .*\/\<(klick|verwende|folge|benutz)([^.?!]|$)+\<(http|www|link|url)\>
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }
  
  # Wie schon die TV-Werbung zeigte:
  :0 HB
  * .*\/\<as\<seen\>on
  { CHECK="NiX-
NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # "my name is" kommt fast nur in anonymen Mails vor:
  :0 B
  * .*\/\<my\<+name\>+is
  { CHECK="NiX-
NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # Ich bin, also spamme ich:
  :0 DB
  * .*\/\<I(\<+[aA]|'`)[mM]\>+[A-Z][a-zA-Z]
  { CHECK="NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }
  
  # Auf den Empfaenger mit Gebruell:
  :0 B
  * .*\/!.*!.*!.*!
  { CHECK="NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # Ein paar HTML-Tests, falls HTML-Mail:
  :0 HB
  * ^Content.*/html
  {
    # HTML-Tags als Text-Zerhacker:
    : 0 B
    * .*\/[a-z](=3C|<)[^>]*(>|=3E)[a-z](.*[a-z])?(=3C|<)[^>]*(>|=3E)[a-z]
    { CHECK="NiX-
NiX-
NiX-HTML_TRASH: $MATCH
$CHECK" }

    # numerisch kodiertes HTML:
    : 0 B
    * .*\/[&%][#x0-9]+[0-9].*[&%][#x0-9]+[0-9].*[&%][#x0-9]+[0-9]
    { CHECK="NiX-
NiX-
NiX-NUMERIC_HTML: $MATCH
$CHECK" }

    # User-Tracking mit nachgeladenen Bildern etc.:
    :0 B
    * .*(<|=3C)(=$)*[a-z]([^>]|$)+(backgr|ound|s(=$)*r(=$)*c(=$)*)([^>]|$)*=\
       ([^>]|$)*\/(h|..104;)(=$)*(t|..116;)(=$)*(t|..116;)(=$)*(p|..112;)(:|.3A|..58)[^>"]*
    # IVW-Zaehler kommen in erwuenschten Newslettern vor:
    * ! MATCH ?? [^a-z]ivw
    { CHECK="NiX-
NiX-
NiX-REMOTE_CONTENT: $MATCH
$CHECK" }
  }

  # Schlanker Spam mit URL gleich zu Beginn ...
  :0 B
  * ^^($|\>|(<|=3C).*(>|=3E))*\/.*http(:|.3A)(/|.2F)
  { CHECK="NiX-
NiX-FIRST_LINE_URL: $MATCH
$CHECK" }

  # ... und / oder mit URLs in jeder Zeile:
  :0 B
  * 1^1 ^.*http(:|.3A)(/|.2F)
  * -1^1 ^[^=<].
  { CHECK="NiX-
NiX-URLS_ONLY
$CHECK" }

  # numerisch, hexadezimal oder mit "@" verkleidete URL:
  :0 B
  * .*\/http(:|.3A)(/|.2F)+([.0-9]+|[^/ >]*[*@%][^/ >]*)(/|(=|%)2F)
  { CHECK="NiX-
NiX-
NiX-CRYPTIC_URL: $MATCH
$CHECK" }

  # URLs, die man besser nicht anklickt:
  :0 B
  * .*\/(http|www)[^> ]*(casino|teen|virgin|free[^nm]|porn|m.rtgage|needthis|\
    penis|price|auction|sale[sz]|deal[sz]|promo|offer[sz]|yeah|thebest|[1-9]\.name-|\
    lycos|you|tripod|terra\.es|geocities|hgh|domains|dialer|safely|365|consumer|\
    girl[sz]|cheap|cash|special.?offer|bargain|stuff|pharm|herb(al|power)|slut[sz]|yehey|\
    grow|watchme|large|trade|j-connect|drugs|discount|saving)
  * ! MATCH ?? (=20|=3E)
  { CHECK="NiX-
NiX-
NiX-SPAM_LINK: $MATCH
$CHECK" }

  # URLs, die man besser nicht anklickt:
  :0 B
  * .*\/(http|www)[^> ]+(quit|exit|\.to/|click|track|\
    mail=|goodb|re?mo?v|(pre|sub)scr|unsub|opt.?(in|out)|\
    thank|pleas|\<(stop|off)\.|member|join|submi|aff(il|_?id)|\
    (/|(=|%)2F)[^> ]*((@|(=|%)40)|(\.|(=|%)2E)exe\>))
  * ! MATCH ?? (=20|=3E)
  { CHECK="NiX-
NiX-
NiX-SPAM_LINK: $MATCH
$CHECK" }

  # Kennt jemand eine serioese .biz-Seite?
  :0 B
  * .*\/(http|www)[^> ]+(\.biz/)
  { CHECK="NiX-
NiX-SPAM_LINK: $MATCH
$CHECK" }

  # Diverse Spam-Formulierungen: 
  :0 B
  * .*\/your(=|20|$| |	)*([<>#&$*]|priva|domain|bank|account|credit|\
     pen|free|purch|money|own|busi|home|cable|mortg|heal|situ|web|response|\
     luck|winn|urgent|lov)
  { CHECK="NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # "Dies ist kein Spam" 1: 
  :0 B
  * .*\/\<w(ir|e)\>([^.?!]|$)+\<(sen(d|t)|do)([^.?!]|$)+(unsoli|spam)
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # "Dies ist kein Spam" 2: 
  :0 B
  * .*\/\<((bill|S\.)([^.?!]|$)*1618|3113([^.?!]|$)+act)
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-
NiX-
NiX-SPAM_BY_LAW: $MATCH
$CHECK" }

  # "Dies ist kein Spam" 3a (leider auch in "Disclaimern"): 
  :0 B
  * .*\/\<you\>([^.?!]|$)*this([^.?!]|$)*(message|mail|letter|info)
  * ! MATCH ?? (=2E|=21|=3F|delete|recipi|virus|sender)
  { CHECK="NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # "Dies ist kein Spam" 3b (leider auch in "Disclaimern"): 
  :0 B
  * .*\/\<sie\>([^.?!]|$)*dies([^.?!]|$)*(mail|letter|info)
  * ! MATCH ?? (=2E|=21|=3F|nger|virus|sender|schen|benach)
  { CHECK="NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # "Dies ist kein Spam" 4: 
  :0 B
  * .*\/\<(dies|this)([^.?!]|$)+(one.?time|spam|unsoli)
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # Werden Sie Mitglied:
  :0 B
  * .*\/\<you([^.?!]|$)+\<member
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # Hier kriegen Sie Geld:
  :0 B
  * .*\/\<(get|receive)([^.?!]|$)*\<(money|pa(i|y)|\$|Dollar)
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # Sie koennen sich gerne abmelden 1:
  :0 B
  * .*\/\<you([^.?!]|$)+opt.?.?.?(in|out)
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # Sie koennen sich gerne abmelden 2:
  :0 B
  * .*\/\<(zuk|future|further)([^.?!]|$)+(inform|letter|mail|offer)
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # Sie koennen sich gerne abmelden 3:
  :0 B
  * .*\/\<(opt|remov)([^.?!]|$)+instruct
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # Sie koennen sich gerne abmelden 4:
  :0 B
  * .*\/\<honor([^.?!]|$)+remov|remov([^.?!]|$)+(http|www|honor|request)
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # Sie koennen sich gerne abmelden 5:
  :0 B
  * .*\/\<(to|you)[^.?!]*\<(unsu|remov)
  * ! MATCH ?? (=2E|=21|=3F|virus)
  { CHECK="NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # Betteln um Reaktion:
  :0 B
  * .*\/\<please([^.?!a-z]|$)+(visit|send|respond|reply|(fo|a)llow)
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # Danke fuers Lesen oder: Tut uns echt Leid, diese Mail:
  :0 B
  * [.?!]\/([^.?!]|$)+(thank|apolog)([^.?!]|$)+[.?!]
  * MATCH ?? this($|.)*(mail|message|letter)
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # Nur heute im Sonderangebot:
  :0 B
  * .*\/\<((save|less|only|just)([^.?!]|$)*\<(\$|dollar|day)|\
    \<(\$|dollar|day)([^.?!]|$)*\<(save|less|only)|\
    \<(valu|this|special|great|limited)([^.?!]|$)*\<(offer|price))
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

   # Bestellen Sie endlich:
  :0 B
  * .*\/\<(order([^:.?!]|$)+(here|you|now|today)|you([^:.?!]|$)*\<order)
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-
NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

   # Rufen Sie an:
  :0 B
  * .*\/\<(please|you)([^.?!]|$)*\<call
  * ! MATCH ?? (=2E|=21|=3F)
  { CHECK="NiX-SPAM_KEYWORDS: $MATCH
$CHECK" }

  # 0190-Werbung:
  :0 B
  * ^\/.*(\<(0|null)[^a-z0-9]*(1|eins)[^a-z0-9]*(9|neun)[^a-z0-9]*(0|null)).*$?.*$?
  * MATCH ?? (\>|[0-9])+(=80|euro?|cent|ct|s(\>|e(c|k))|min(\>|ute))
  { CHECK="NiX-
NiX-
NiX-SPAM_KEYWORDS: $MATCH$CHECK" }

  # mehrere einzelne Zeichen:
  :0 B
  * .*\/[^0-9a-z][a-z][^0-9a-z][a-z][^0-9a-z]\
    [a-z][^0-9a-z][a-z][^0-9a-z]
  { CHECK="NiX-BODY_SPACED: $MATCH
$CHECK" }
  
  # Endgueltige Einordnung in Spam / verdaechtig / Ham:
  :0 D
  * -6^0
  * -2^3 CHECK ?? ^-OK-
  * 1^1 CHECK ?? ^NiX-
  { RESULT="SPAM" }
  :0 ED
  * -3^0
  * -2^2 CHECK ?? ^-OK-
  * 1^1 CHECK ?? ^NiX-
  { RESULT="MAYBESPAM" }
  :0 ED
  { RESULT="HAM" }
}
:0E
{ CHECK="BODY_TESTS_SKIPPED
$CHECK" }

# Datum und Uhrzeit extrahieren:
:0
* ()\/[^ ]+ +[^ ]+( +[1-9][0-9][0-9]+)? +..:..:..
{ DATE=$MATCH }

# Ausliefernden Host sichern, falls noch nicht geschehen:
:0 D
* ! CHECK ?? ^-OK-WHITELIST
* GATEWAY_IP ?? .
{
  :0 Dw
  * RESULT ?? ^^SPAM^^
  # nochmals checken zur Vermeidung mehrfacher Eintragungen:
  * ! ? fgrep -s -- " $GATEWAY_IP" $BLACKLIST
  { CHECK="NEW BLACKLIST ENTRY:	$GATEWAY_IP	$REVERSELOOKUP
$CHECK"
    :0 hci:
    | echo "$DATE $GATEWAY_IP	$REVERSELOOKUP" >> $BLACKLIST
  }
  # Nur "besonders erwuenschte" Mails sorgen fuer Whitelist-Eintrag:
  :0 EDw
  * RESULT ?? ^^HAM^^
  * 1^0
  * 3^1 CHECK ?? ^-OK-
  * -1^1 CHECK ?? ^NiX-
  # nochmals checken zur Vermeidung mehrfacher Eintragungen:
  * ! ? fgrep -s -- " $GATEWAY_IP" $WHITELIST
  { CHECK="NEW WHITELIST ENTRY:	$GATEWAY_IP	$REVERSELOOKUP
$CHECK"
    :0 hci:
    | echo "$DATE $GATEWAY_IP	$REVERSELOOKUP" >> $WHITELIST
  }
}

# Eintrag in bereinigte Blacklist bei Checksum- oder
# Blacklist-Treffern, falls noch nicht enthalten:
:0 Dhciw:
* RESULT ?? ^^SPAM^^
* CHECK ?? ^NiX-(BLACKLIST|CHECKSUM)
* ! CHECK ?? ^-OK-WHITELIST
* GATEWAY_IP ?? .
# folgende Zeile auskommentieren, falls jeder Treffer hinein soll:
* ! ? fgrep -s -- " $GATEWAY_IP" $BLACKMATCHES
  | echo "$DATE $GATEWAY_IP	$REVERSELOOKUP" >> $BLACKMATCHES

# Eintrag in bereinigte Whitelist nur bei genauem IP-Treffer
# und nicht bei Mehrfach-Mails:
:0 EDhciw:
* CHECK ?? WHITELIST_MATCH
* RESULT ?? ^^HAM^^
* GATEWAY_IP ?? .
* ! CHECK ?? ^NiX-CHECKSUM
* ? fgrep -s -- " $GATEWAY_IP" $WHITELIST
* ! ? fgrep -s -- " $GATEWAY_IP" $WHITEMATCHES
  | echo "$DATE $GATEWAY_IP	$REVERSELOOKUP" >> $WHITEMATCHES

# Auch Checksum-Matches extra mitfuehren (nur bei Spam):
:0 D
* CHECK ?? CHECKSUM.?_SPAM: \/.*
{ CACHEMATCH=$MATCH
  :0 hciw:
  * ! ? fgrep -s -- "$CACHEMATCH" $CACHEMATCHES
  | echo "$DATE	$CACHEMATCH" >> $CACHEMATCHES
}

# sonst Hash - wenn vorhanden - sichern:
:0 EDhci:
* RESULT ?? ^^SPAM^^
* md5hash ?? .
# ... Hash in Spam-Cache speichern, falls noch nicht in Datei:
| echo "$DATE	$md5hash" >> $SPAMCACHE

# Zentrale Spam-Statistik:
:0
* RESULT ?? ^^SPAM^^
{
  :0
  * ^Return-path: <\/[^>]+
  { ENV_FROM=$MATCH }
  :0 Dhci:
  * CHECK ?? .*\/(CHECKSUM.?_SPAM|BLACKLIST_MATCH).*
  | echo "$DATE	$LOGNAME	$MATCH	$ENV_FROM" >> $STATS
  :0ED
  * 1^1 CHECK ?? ^NiX
  { NIXCOUNT="$="
    :0 hci:
    | echo "$DATE	$LOGNAME	no match, NiX count: $NIXCOUNT		$ENV_FROM" >> $STATS
  }
  :0D
  * CHECK ?? ^-OK-WHITELIST
  # Eigentlich verpoent, aber in diesem Ausnahmefall
  # sei eine Subject-Manipulation erlaubt:
  {
    :0 fhw
    * ^Subject:\/.*
    | formail -i "Subject: [SPAM VON WHITELIST-TREFFER $GATEWAY_IP]$MATCH"
    :0 Efhw
    | formail -I "Subject: [SPAM VON WHITELIST-TREFFER $GATEWAY_IP]"
  }
}
:0E
# Test nicht zu spammiger Mails auf schon eingegangene Bodies:
* ! CHECK ?? ^-OK-(HOST|VERTEILER)
* md5hash ?? .
# Nicht bei Mails an Verteiler oder mit mehreren Adressaten laut Header:
* $ ! ^(Resent|CC:).*$MY_DOMAIN
* $ ! ^To:.*$MY_DOMAIN.*,.*$MY_DOMAIN
{
  :0Dci:
  # ... Hash speichern, falls noch nicht in Datei:
  * ! CHECK ?? ^NiX-CHECKSUM
  | echo "$DATE	$md5hash" >> $MD5CACHE
  :0E
  # Doppelte Mails (nicht externe, weitergeleitete) markieren:
  * ! ^X.*forward:
  { CHECK="MEHRFACH
$CHECK"
    :0fhw
    * ENVELOPE_TO ?? @
    | formail -i "To: Diese Mail ging mehrmals an die Abteilung! <$ENVELOPE_TO>"
  }
}

# Spam sichern, falls Variable "BACKUP" existiert:
:0 D
* BACKUP ?? y
* RESULT ?? ^^SPAM
{ CHECK="BACKUP
$CHECK" 
  :0c:
  $NIXDIR/spam-mail-backup
}
:0 E
* BACKUP ?? y
* RESULT ?? ^^MAYBESPAM
{ CHECK="BACKUP
$CHECK" 
  :0c:
  $NIXDIR/maybespam-mail-backup
}
:0 E
{ CHECK="NO_BACKUP
$CHECK" }

##############################################
### Moegliches Ende einer INCLUDERC-Datei, ###
### so bindet man sie z.B. ggf. ein:       ###
### INCLUDERC=/KOMPLETTERPFAD/nixspam.rc   ###
##############################################

# Spam entsorgen (Vorsichtige stellen Spam in eigenen Ordner zu),
# loeschen wie hier sollte mit "BACKUP=yes" (s. o.) einhergehen!
:0 D
* RESULT ?? ^^SPAM^^
$MY_SPAMFOLDER

# Nicht so sicheren Spam zustellen:
:0 D
* RESULT ?? ^^MAYBESPAM^^
$MY_SPAMFOLDER

# Hier landen alle restlichen Mails:

# [JM]
# check with spamasssassin if under 256kb
# $CONFIGFOR is the account's email address. This, together
# with some settings in /etc/default/spamassassin makes
# it possible to have per-user configuration in $SW/domain/userdir
# [/JM]
:0fw: spamassassin.lock
* < 256000
| /usr/bin/spamc -u $CONFIGFOR

:0
* LOGFILE ?? .
{ CHECK="SPAMLEVEL=$SPAMLEVEL
$CHECK" }

# Spam-Flag is YES if the score is greater than the
# Ingo-managed user_prefs says
:0
* ^X-Spam-Flag: YES
{
    CHECK="SPAMASSASSIN_HIT
$CHECK"
    :0
    $MY_SPAMFOLDER
}

:0
* LOGFILE ?? .
{ LOG="
$CHECK" }

#:0
#$DEFAULT/
#       ^ important!
